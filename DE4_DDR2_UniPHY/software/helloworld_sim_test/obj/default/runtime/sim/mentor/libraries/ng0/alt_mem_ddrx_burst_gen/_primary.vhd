library verilog;
use verilog.vl_types.all;
entity alt_mem_ddrx_burst_gen is
    generic(
        CFG_DWIDTH_RATIO: integer := 4;
        CFG_CTL_ARBITER_TYPE: string  := "ROWCOL";
        CFG_REG_GRANT   : integer := 0;
        CFG_MEM_IF_CHIP : integer := 1;
        CFG_MEM_IF_CS_WIDTH: integer := 1;
        CFG_MEM_IF_BA_WIDTH: integer := 3;
        CFG_MEM_IF_ROW_WIDTH: integer := 13;
        CFG_MEM_IF_COL_WIDTH: integer := 10;
        CFG_LOCAL_ID_WIDTH: integer := 10;
        CFG_DATA_ID_WIDTH: integer := 10;
        CFG_INT_SIZE_WIDTH: integer := 4;
        CFG_AFI_INTF_PHASE_NUM: integer := 2;
        CFG_PORT_WIDTH_TYPE: integer := 3;
        CFG_PORT_WIDTH_BURST_LENGTH: integer := 5;
        CFG_PORT_WIDTH_TCCD: integer := 4;
        CFG_PORT_WIDTH_ENABLE_BURST_INTERRUPT: integer := 1;
        CFG_PORT_WIDTH_ENABLE_BURST_TERMINATE: integer := 1;
        CFG_ENABLE_BURST_GEN_OUTPUT_REG: integer := 0
    );
    port(
        ctl_clk         : in     vl_logic;
        ctl_reset_n     : in     vl_logic;
        cfg_type        : in     vl_logic_vector;
        cfg_burst_length: in     vl_logic_vector;
        cfg_tccd        : in     vl_logic_vector;
        cfg_enable_burst_interrupt: in     vl_logic_vector;
        cfg_enable_burst_terminate: in     vl_logic_vector;
        arb_do_write    : in     vl_logic_vector;
        arb_do_read     : in     vl_logic_vector;
        arb_do_burst_chop: in     vl_logic_vector;
        arb_do_burst_terminate: in     vl_logic_vector;
        arb_do_auto_precharge: in     vl_logic_vector;
        arb_do_rmw_correct: in     vl_logic_vector;
        arb_do_rmw_partial: in     vl_logic_vector;
        arb_do_activate : in     vl_logic_vector;
        arb_do_precharge: in     vl_logic_vector;
        arb_do_precharge_all: in     vl_logic_vector;
        arb_do_refresh  : in     vl_logic_vector;
        arb_do_self_refresh: in     vl_logic_vector;
        arb_do_power_down: in     vl_logic_vector;
        arb_do_deep_pdown: in     vl_logic_vector;
        arb_do_zq_cal   : in     vl_logic_vector;
        arb_do_lmr      : in     vl_logic_vector;
        arb_to_chipsel  : in     vl_logic_vector;
        arb_to_chip     : in     vl_logic_vector;
        arb_to_bank     : in     vl_logic_vector;
        arb_to_row      : in     vl_logic_vector;
        arb_to_col      : in     vl_logic_vector;
        arb_localid     : in     vl_logic_vector;
        arb_dataid      : in     vl_logic_vector;
        arb_size        : in     vl_logic_vector;
        bg_do_write_combi: out    vl_logic_vector;
        bg_do_read_combi: out    vl_logic_vector;
        bg_do_burst_chop_combi: out    vl_logic_vector;
        bg_do_burst_terminate_combi: out    vl_logic_vector;
        bg_do_activate_combi: out    vl_logic_vector;
        bg_do_precharge_combi: out    vl_logic_vector;
        bg_to_chip_combi: out    vl_logic_vector;
        bg_effective_size_combi: out    vl_logic_vector;
        bg_interrupt_ready_combi: out    vl_logic;
        bg_do_write     : out    vl_logic_vector;
        bg_do_read      : out    vl_logic_vector;
        bg_do_burst_chop: out    vl_logic_vector;
        bg_do_burst_terminate: out    vl_logic_vector;
        bg_do_auto_precharge: out    vl_logic_vector;
        bg_do_rmw_correct: out    vl_logic_vector;
        bg_do_rmw_partial: out    vl_logic_vector;
        bg_do_activate  : out    vl_logic_vector;
        bg_do_precharge : out    vl_logic_vector;
        bg_do_precharge_all: out    vl_logic_vector;
        bg_do_refresh   : out    vl_logic_vector;
        bg_do_self_refresh: out    vl_logic_vector;
        bg_do_power_down: out    vl_logic_vector;
        bg_do_deep_pdown: out    vl_logic_vector;
        bg_do_zq_cal    : out    vl_logic_vector;
        bg_do_lmr       : out    vl_logic_vector;
        bg_to_chipsel   : out    vl_logic_vector;
        bg_to_chip      : out    vl_logic_vector;
        bg_to_bank      : out    vl_logic_vector;
        bg_to_row       : out    vl_logic_vector;
        bg_to_col       : out    vl_logic_vector;
        bg_doing_write  : out    vl_logic;
        bg_doing_read   : out    vl_logic;
        bg_rdwr_data_valid: out    vl_logic;
        bg_interrupt_ready: out    vl_logic;
        bg_localid      : out    vl_logic_vector;
        bg_dataid       : out    vl_logic_vector;
        bg_size         : out    vl_logic_vector;
        bg_effective_size: out    vl_logic_vector
    );
    attribute mti_svvh_generic_type : integer;
    attribute mti_svvh_generic_type of CFG_DWIDTH_RATIO : constant is 1;
    attribute mti_svvh_generic_type of CFG_CTL_ARBITER_TYPE : constant is 1;
    attribute mti_svvh_generic_type of CFG_REG_GRANT : constant is 1;
    attribute mti_svvh_generic_type of CFG_MEM_IF_CHIP : constant is 1;
    attribute mti_svvh_generic_type of CFG_MEM_IF_CS_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_MEM_IF_BA_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_MEM_IF_ROW_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_MEM_IF_COL_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_LOCAL_ID_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_DATA_ID_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_INT_SIZE_WIDTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_AFI_INTF_PHASE_NUM : constant is 1;
    attribute mti_svvh_generic_type of CFG_PORT_WIDTH_TYPE : constant is 1;
    attribute mti_svvh_generic_type of CFG_PORT_WIDTH_BURST_LENGTH : constant is 1;
    attribute mti_svvh_generic_type of CFG_PORT_WIDTH_TCCD : constant is 1;
    attribute mti_svvh_generic_type of CFG_PORT_WIDTH_ENABLE_BURST_INTERRUPT : constant is 1;
    attribute mti_svvh_generic_type of CFG_PORT_WIDTH_ENABLE_BURST_TERMINATE : constant is 1;
    attribute mti_svvh_generic_type of CFG_ENABLE_BURST_GEN_OUTPUT_REG : constant is 1;
end alt_mem_ddrx_burst_gen;
